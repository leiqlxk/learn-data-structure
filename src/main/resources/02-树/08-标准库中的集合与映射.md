由于ArryList和LinkedList用于查找效率很低。因此Collections API提供了两个附加容器Set和Map，他们对诸如插入、删除和查找
等基本操作提供有效实现。
## 关于Set接口
1. Set接口代表不允许重复元素的Collection。由接口SortedSet给出一种特殊类型的Set保证其中的各项处于有序的状态。Set是
Collection的子类，所以用于继承Collection中的方法也是有效的。
1. 由于Set所要求的一些独特的操作是一些插入、删除以及执行基本查找的能力。对于Set的add方法如果执行成功则返回true，否则返回
false，因为被添加的项已经存在。保持各项以有序状态的Set的实现是TreeSet。
1. 默认情况下，排序假设TreeSet中的项实现Comparable接口。另一种排序可以通过Comparator实例化TreeSet来确定。
## 关于Map接口
1. Map是一个接口，代表由关键字以及它们的值组成的一些项的集合。关键字必须是唯一的，但是若干关键字可以映射到一些相同的值。
因此值不必是唯一的。在SortedMap接口中，映射中的关键字保持逻辑上有序状态。SortedMap接口的一种实现TreeMap类。Map的基本
操作包括诸如IsEmpty，clear，size等方法，最重要的是containsKey，get，put。
1. get返回Map中与key相关的值，或当key不存在时返回null。如果Map中不存在null值，那么get返回的值可以用来确定key是否在
Map中。然后如果存在null值，那么必须使用ContainsKey。方法put把关键字/值对植入Map中，或者返回null，或者返回与key相联系
的老值。
1. 通过一个Map进行迭代要比Collection复杂，因为Map不提供迭代器，而是提供3中方法，将Map对象的视图作为Collection对象返
回：Set<E> keySet、Collection<E> values、Set<Map.Entry<E, V>> entrySet。
## TreeSet类和TreeMap类的实现
1. java要求TreeSet和TreeMap支持基本的add、remove和contains操作以对数最坏情形时间完成。因此基本的实现就是平衡二叉查
找树。一般来说我们并不使用AVL树，而是经常使用一些自顶向下的红黑树。
1. 实现TreeSet和TreeMap的一个重要问题是提供对迭代器类的支持。在内部迭代器保留到迭代中当前节点的一个链接。困难部分是到
像一个节点高效的推进。存在几种可能的解决方案：
    1. 在构造迭代器时，让每个迭代器把包含TreeSet项的数组作为该迭代器的数据存储。这中方法的问题在于使用toArray并不需要
    迭代器。
    1. 让迭代器保留存储通向当前节点路径上的节点的一个栈。根据该信息可以推出迭代器中的下一个节点，它或者包含最小项的当前
    节点右子树上的节点，或者包含其左子树当前节点的最近祖先。这使得迭代器有些大，并导致迭代器的代码臃肿。
    1. 让查找树中的每个节点除存储子节点外还要存储它的父节点。此时迭代器不至于那么大，但是在每个节点上需要额外的内存，并
    且迭代器的代码仍然臃肿。
    1. 让每个节点保存两个附加的链：一个通向下一个更小的节点，另一个通向下一个更大的节点。这要占用空间，不过迭代器做起来
    非常简单，并且保留这些链也很容易。
    1. 只对那些具有null左链或者null右链的节点保留附加的链。通过使用附加的布尔变量使得这些例程判断是一个左链正在被用作
    标准二叉树左链还是一个通向下一个更下节点的链，这种做法叫做线索数，用于许多平衡二叉查找树的实现中。